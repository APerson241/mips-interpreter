<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>MIPS Interpreter QUnit Test</title>
    <meta name="description" content="MIPS Assembly Interpreter written in Javascript">
    <link rel="stylesheet" type="text/css" href="static/qunit-1.23.0.css">
</head>
<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="static/qunit-1.23.0.js"></script>
    <script src="static/mips.js"></script>
    <script type="text/javascript">
        "use strict";
        var p;

        QUnit.test("greater than 16-bit immediate", function(assert) {
            p = new Program('addiu $1, $1, 0x17fff');
            p.run();
            assert.ok(p.getRegisters()[1] == (0x7fff | 0), "addiu zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "addiu immediate error is present");
            p = new Program('addiu $1, $1, 0x1ffff');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xffffffff | 0), "addiu one extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "addiu immediate error is present");

            p = new Program('addiu $1, $1, 0xffff\nandi $2, $1, 0xff0f0\nandi $3, $1, 0x11111');
            p.run();
            assert.ok(p.getRegisters()[2] == (0xf0f0 | 0), "andi always zero extended immediate truncated to 16-bit");
            assert.ok(p.getRegisters()[3] == (0x1111 | 0), "andi always zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 2, "andi immediate error is present");

            p = new Program('ori $1, $1, 0xff0f0');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xf0f0 | 0), "ori always zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "ori immediate error is present");
            p = new Program('ori $1, $1, 0x11111');
            p.run();
            assert.ok(p.getRegisters()[1] == (0x1111 | 0), "ori always zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "ori immediate error is present");

            p = new Program('addiu $1, $1, 0xffff\nxori $1, $1, 0xff0f0');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xffff0f0f | 0), "xori always zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "addiu immediate error is present");
            p = new Program('addiu $1, $1, 0xffff\nxori $1, $1, 0x11111');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xffffeeee | 0), "xori always zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "addiu immediate error is present");

            p = new Program('addiu $1, $1, 0x8\nslti $2, $2, 0x10000');
            p.run();
            assert.ok(p.getRegisters()[2] == (0x0 | 0), "slti zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "slti immediate error is present");
            p = new Program('addiu $1, $1, 0x8\nslti $2, $2, 0xf7fff');
            p.run();
            assert.ok(p.getRegisters()[2] == (0x1 | 0), "slti zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "slti immediate error is present");

            p = new Program('addiu $1, $1, 0x8\nsltiu $2, $2, 0x10000');
            p.run();
            assert.ok(p.getRegisters()[2] == (0x0 | 0), "sltiu zero extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "sltiu immediate error is present");
            p = new Program('addiu $1, $1, 0x8\nsltiu $2, $2, 0xfffff');
            p.run();
            assert.ok(p.getRegisters()[2] == (0x1 | 0), "sltiu one extended immediate truncated to 16-bit");
            assert.ok(p.getErrors().length == 1, "sltiu immediate error is present");
        });

        QUnit.test("reject unsupported operands", function(assert) {
            p = new Program("add $4, $4, $4");
            p.run();
            assert.ok(p.getErrors().length == 1, "error with add (supported is addu)");

            p = new Program("nori $3, $1, $0\nasdf $20, $19, $10");
            p.run();
            assert.ok(p.getErrors().length == 2, "errors compound with two unspported instructions");
        });

        QUnit.test("addiu", function(assert) {
            p = new Program('addiu $1, $1, 0xdead');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xffffdead | 0), "Immediate is one sign extended");

            p = new Program('addiu $1, $1, 0x7fff');
            p.run();
            assert.ok(p.getRegisters()[1] == (0x7fff | 0), "Immediate is zero sign extended");

            p = new Program('addiu $1, $1, 0xffff\naddiu $2, $1, 0x1');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xffffffff | 0), "Immediate is one sign extended");
            assert.ok(p.getRegisters()[2] == (0x0 | 0), "Immediate should is zero extended, sum is 0");
        });

        QUnit.test("andi", function(assert) {
            p = new Program('addiu $1, $1, 0xffff\nandi $2, $1, 0xf0f0\nandi $3, $1, 0x1');
            p.run();
            assert.ok(p.getRegisters()[2] == (0xf0f0 | 0), "Immediate is always zero extended");
            assert.ok(p.getRegisters()[3] == (0x1 | 0), "Immediate is always zero extended");
        });

        QUnit.test("ori", function(assert) {
            p = new Program('addiu $1, $1, 0x70f0\nori $2, $1, 0x0f0f');
            p.run();
            assert.ok(p.getRegisters()[2] == (0x7fff | 0), "Immediate is always zero extended");

            p = new Program('addiu $1, $1, 0xffff\nori $2, $1, 0x0');
            p.run();
            assert.ok(p.getRegisters()[2] == (0xffffffff | 0), "Ori should not change original value if immediate is 0");
        });

        QUnit.test("xori", function(assert) {
            p = new Program('addiu $1, $1, 0xffff\nxori $2, $1, 0x1');
            p.run();
            assert.ok(p.getRegisters()[2] == (0xfffffffe | 0), "Immediate is always zero extended");

            p = new Program('addiu $1, $1, 0xffff\nxori $2, $1, 0xffff');
            p.run();
            assert.ok(p.getRegisters()[2] == (0xffff0000 | 0), "Immediate is always zero extended");
        });

        QUnit.test("slti", function(assert) {
            p = new Program('addiu $1, $1, 0x4\nslti $2, $1, 0x8');
            p.run();
            assert.ok(p.getRegisters()[2] == (1 | 0), "Value is less than zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nslti $2, $1, 0x3');
            p.run();
            assert.ok(p.getRegisters()[2] == (0 | 0), "Value is not less than zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nslti $2, $1, 0x4');
            p.run();
            assert.ok(p.getRegisters()[2] == (0 | 0), "Value is equal to zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nslti $2, $1, 0xffff');
            p.run();
            assert.ok(p.getRegisters()[2] == (0 | 0), "Value is not less than one sign extended immediate");
        });

        QUnit.test("sltiu", function(assert) {
            p = new Program('addiu $1, $1, 0x4\nsltiu $2, $1, 0x5');
            p.run();
            assert.ok(p.getRegisters()[2] == (1 | 0), "Value is less than zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nsltiu $2, $1, 0x4');
            p.run();
            assert.ok(p.getRegisters()[2] == (0 | 0), "Value is equal to zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nsltiu $2, $1, 0x3');
            p.run();
            assert.ok(p.getRegisters()[2] == (0 | 0), "Value is not less than zero sign extended immediate");

            p = new Program('addiu $1, $1, 0x4\nsltiu $2, $1, 0xffff');
            p.run();
            assert.ok(p.getRegisters()[2] == (1 | 0), "Value is less than one sign extended immediate");
        });

        QUnit.test("writing to $0", function(assert) {
            p = new Program('addiu $0, $0, 0xbeef');
            p.run();
            assert.ok(p.getRegisters()[0] === 0, "Cannot write to $0 register");

            p = new Program('ori $3, $0, 0x123\nori $5, $0, 0x321\naddu $0, $3, $5');
            p.run();
            assert.ok(p.getRegisters()[0] === 0, "Cannot write to $0 register");
        });

        function setupTest(instructions) {
            var program = new Program(instructions);
            for (var i = 0; i < 32; ++i) {
                program.registers[i] = i | 0;
            }
            return program;
        }

        QUnit.test("addu", function(assert) {
            p = setupTest('addu $5, $1, $5');
            p.run();
            assert.ok(p.getRegisters()[5] == 6,  "5 + 1 = 6");

            p = setupTest('addu $2, $2, $1');
            p.registers[2] = 0x7fffffff | 0;
            p.run();
            assert.ok(p.getRegisters()[2] == (0x80000000 | 0), "Overflow");

            p = setupTest('addu $2, $2, $1');
            p.registers[1] = -1 | 0;
            p.registers[2] = 0x80000000 | 0;
            p.run();
            assert.ok(p.getRegisters()[2] == (0x7fffffff | 0), "Underflow");
        });

        QUnit.test("subu", function(assert) {
            p = setupTest('subu $5, $5, $1');
            p.run();
            assert.ok(p.getRegisters()[5] = 4, "5 - 1 = 4");

            p = setupTest('subu $2, $2, $1');
            p.registers[1] = 0xffffffff | 0;
            p.registers[2] = 0x7fffffff | 0;
            p.run();
            assert.ok(p.getRegisters()[2] == (0x80000000 | 0), "Overflow");

            p = setupTest('subu $2, $2, $1');
            p.registers[2] = 0x80000000 | 0;
            p.run();
            assert.ok(p.getRegisters()[2] == (0x7fffffff | 0), "Underflow");
        });

        QUnit.test("and", function(assert) {
            p = setupTest('and $4, $4, $4');
            p.run();
            assert.ok(p.getRegisters()[4] == 4, "4 & 4 = 4");

            p = setupTest('and $1, $31, $2');
            p.run();
            assert.ok(p.getRegisters()[1] == 2, "31 & 2 = 2");
        });

        QUnit.test("or", function(assert) {
            p = setupTest('or $1, $8, $7');
            p.run();
            assert.ok(p.getRegisters()[1] == 15, "8 | 7 = 15");

            p = setupTest('or $5, $0, $5');
            p.run();
            assert.ok(p.getRegisters()[5] == 5, "5 | 0 = 5");
        });

        QUnit.test("xor", function(assert) {
            p = setupTest('xor $5, $5, $5');
            p.run();
            assert.ok(p.getRegisters()[5] == 0, "5 ^ 5 = 0");

            p = setupTest('xor $1, $10, $5');
            p.run();
            assert.ok(p.getRegisters()[1] == 15, "10 ^ 5 = 15");
        });

        QUnit.test("nor", function(assert) {
            p = setupTest('nor $1, $10, $5');
            p.run();
            assert.ok(p.getRegisters()[1] == (0xfffffff0 | 0), "~(10 | 5) = -16");

            p = setupTest('nor $3, $8, $9');
            p.run();
            assert.ok(p.getRegisters()[3] == (0xfffffff6 | 0), "~(10 | 5) = -10");
        });

        // TODO: verify little endianness
        // TODO: verify jump/branches conditions
        QUnit.test("beq", function(assert) {
            p = new Program('beq $0, $0, 0x8 \n addiu $1, $1, 1 \n ori $5, $5, 0xdead \n ori $4, $4, 0xbabe');
            p.run();
            assert.ok(p.getRegisters()[1] == 1, "Condition true: Delay slot instruction is executed");
            assert.ok(p.getRegisters()[5] != 0xdead, "Condition true: Branch is taken");
            assert.ok(p.getRegisters()[4] == 0xbabe , "Condition true: Branched instruction is executed");

            p = new Program('ori $1, $1, 0xbeef \n beq $0, $1, 0x8 \n andi $1, $1, 0 \n ori $5, $5, 0xdead \n ori $4, $4, 0xbabe');
            p.run();
            assert.ok(p.getRegisters()[1] == 0, "Condition false: Delay slot instruction is executed, does not affect branch check");
            assert.ok(p.getRegisters()[5] == 0xdead, "Condition false: Branch is not taken");
            assert.ok(p.getRegisters()[4] == 0xbabe , "Condition false: Branch is not taken, all instructions were executed");

            p = new Program('beq $0, $0, -4 \n addiu $1, $1, 1'); // program should continously loop, while executing delay slot instruction
            for (var i = 0; i < 10; ++i) {
                p.step();
            }
            assert.ok(p.getRegisters()[1] == 10, "Negative branch offset to same instruction");

            p = new Program('beq $0, $0, 0x3fffc \n addiu $1, $1, 1'); // program should continously loop, while executing delay slot instruction
            for (var i = 0; i < 10; ++i) {
                p.step();
            }
            assert.ok(p.getRegisters()[1] == 10, "Negative branch offset to same instruction, with signed offset");
        });

        // TODO: verify delay slot
        // TODO: verify labels
    </script>
</body>
